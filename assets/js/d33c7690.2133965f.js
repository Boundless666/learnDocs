"use strict";(self.webpackChunklearn_docs=self.webpackChunklearn_docs||[]).push([[584],{3905:(e,n,u)=>{u.d(n,{Zo:()=>c,kt:()=>d});var t=u(7294);function r(e,n,u){return n in e?Object.defineProperty(e,n,{value:u,enumerable:!0,configurable:!0,writable:!0}):e[n]=u,e}function o(e,n){var u=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),u.push.apply(u,t)}return u}function a(e){for(var n=1;n<arguments.length;n++){var u=null!=arguments[n]?arguments[n]:{};n%2?o(Object(u),!0).forEach((function(n){r(e,n,u[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(u)):o(Object(u)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(u,n))}))}return e}function l(e,n){if(null==e)return{};var u,t,r=function(e,n){if(null==e)return{};var u,t,r={},o=Object.keys(e);for(t=0;t<o.length;t++)u=o[t],n.indexOf(u)>=0||(r[u]=e[u]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)u=o[t],n.indexOf(u)>=0||Object.prototype.propertyIsEnumerable.call(e,u)&&(r[u]=e[u])}return r}var i=t.createContext({}),s=function(e){var n=t.useContext(i),u=n;return e&&(u="function"==typeof e?e(n):a(a({},n),e)),u},c=function(e){var n=s(e.components);return t.createElement(i.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},f=t.forwardRef((function(e,n){var u=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),f=s(u),d=r,q=f["".concat(i,".").concat(d)]||f[d]||p[d]||o;return u?t.createElement(q,a(a({ref:n},c),{},{components:u})):t.createElement(q,a({ref:n},c))}));function d(e,n){var u=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=u.length,a=new Array(o);a[0]=f;var l={};for(var i in n)hasOwnProperty.call(n,i)&&(l[i]=n[i]);l.originalType=e,l.mdxType="string"==typeof e?e:r,a[1]=l;for(var s=2;s<o;s++)a[s]=u[s];return t.createElement.apply(null,a)}return t.createElement.apply(null,u)}f.displayName="MDXCreateElement"},1926:(e,n,u)=>{u.r(n),u.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var t=u(7462),r=(u(7294),u(3905));const o={},a="\u987a\u5e8f\u961f\u5217",l={unversionedId:"stackAndQueue/seqQueue",id:"stackAndQueue/seqQueue",title:"\u987a\u5e8f\u961f\u5217",description:"",source:"@site/docs/03-stackAndQueue/03-seqQueue.md",sourceDirName:"03-stackAndQueue",slug:"/stackAndQueue/seqQueue",permalink:"/learnsDocs/docs/stackAndQueue/seqQueue",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/03-stackAndQueue/03-seqQueue.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\u94fe\u6808",permalink:"/learnsDocs/docs/stackAndQueue/linkedStack"},next:{title:"\u94fe\u961f\u5217",permalink:"/learnsDocs/docs/stackAndQueue/linkedQueue"}},i={},s=[],c={toc:s};function p(e){let{components:n,...u}=e;return(0,r.kt)("wrapper",(0,t.Z)({},c,u,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"\u987a\u5e8f\u961f\u5217"},"\u987a\u5e8f\u961f\u5217"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAXSIZE 10\n\ntypedef char ElemType;\n\ntypedef struct{\n ElemType data[MAXSIZE];\n int front,rear;\n int length;\n}SeqQueue;\n\nvoid InitQueue(SeqQueue *queue);\nbool EnQueue(SeqQueue *queue, ElemType e);\nbool DeQueue(SeqQueue *queue, ElemType *e);\nvoid ShowInfo(SeqQueue queue);\n\nint main(){\n SeqQueue queue;\n InitQueue(&queue); \n EnQueue(&queue, 'A');\n EnQueue(&queue, 'B');\n EnQueue(&queue, 'C');\n EnQueue(&queue, 'D');\n EnQueue(&queue, 'E');\n EnQueue(&queue, 'F');\n EnQueue(&queue, 'G');\n EnQueue(&queue, 'H');\n EnQueue(&queue, 'I');\n EnQueue(&queue, 'J');\n EnQueue(&queue, 'K');//\u7b2c11\u4e2a\n\n ShowInfo(queue);\n\n ElemType result;\n bool status;\n status = DeQueue(&queue, &result);\n printf(\"\u64cd\u4f5c\u72b6\u6001: %d \u8fd4\u56de\u503c: %c \\n\", status, result);\n status = DeQueue(&queue, &result);\n printf(\"\u64cd\u4f5c\u72b6\u6001: %d \u8fd4\u56de\u503c: %c \\n\", status, result);\n\n ShowInfo(queue);\n \n return 0;\n}\n\nbool queueEmpty(SeqQueue *queue){\n if(queue->length == 0){\n  return true;\n } \n return false;\n}\n\nbool queueFull(SeqQueue *queue){\n int rnext = (queue->rear + 1) % MAXSIZE;\n if(rnext == queue->front && queue->length == MAXSIZE){\n  return true;\n }\n return false;\n}\n\nvoid InitQueue(SeqQueue *queue){\n queue->front = queue->length = 0;\n queue->rear = -1;\n}\n\nbool EnQueue(SeqQueue *queue, ElemType e){\n if(queueFull(queue)){\n  printf(\"\u961f\u5217\u5df2\u6ee1\\n\");\n  return false;\n }\n queue->rear = (queue->rear + 1) % MAXSIZE;\n queue->data[queue->rear] = e;\n queue->length++;\n return true;\n}\n\nbool DeQueue(SeqQueue *queue, ElemType *e){\n if(queueEmpty(queue)){\n  printf(\"\u961f\u5217\u4e3a\u7a7a\\n\");\n  return false;\n }\n *e = queue->data[queue->front];\n queue->front = (queue->front + 1) % MAXSIZE;\n queue->length--;\n}\n\n\nvoid ShowInfo(SeqQueue queue){\n int front = queue.front;\n int length = queue.length;\n int order = 1;\n while(length > 0){\n  printf(\"\u961f\u5217\u4e2d\u7b2c %d \u4e2a\u5143\u7d20\u7684\u503c\u4e3a: %c \\n\", order++, queue.data[front]);\n  front = (front + 1) % MAXSIZE;\n  length--;\n }\n printf(\"\\n\\n\");\n}\n")))}p.isMDXComponent=!0}}]);